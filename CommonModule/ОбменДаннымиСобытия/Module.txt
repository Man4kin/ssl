////////////////////////////////////////////////////////////////////////////////
// ЭКСПОРТНЫЕ ВНЕШНИЕ ПРОЦЕДУРЫ И ФУНКЦИИ

// Процедура предназначена для определения вида отправки выгружаемого элемента данных
// Вызывается из обработчиков планов обмена: ПриОтправкеДанныхГлавному(), ПриОтправкеДанныхПодчиненному()
//
// Параметры:
//  ЭлементДанных, ОтправкаЭлемента - см. описание параметров в синтаксис помощнике
//                                    для методов ПриОтправкеДанныхГлавному() и ПриОтправкеДанныхПодчиненному()
//  УзелИнформационнойБазы - ПланОбменаСсылка - текущий узел плана обмена для которого выполняется выгрузка данных
//  ИмяПланаОбмена         - Строка - имя плана обмена как оно задано в конфигураторе
// 
Процедура ПриОтправкеДанных(ЭлементДанных, ОтправкаЭлемента, УзелИнформационнойБазы, ИмяПланаОбмена) Экспорт
	
	Если ТипЗнч(ЭлементДанных) = Тип("УдалениеОбъекта") Тогда
		Возврат; // удаление объекта отсылаем "как есть"
	КонецЕсли;
	
	ОбъектМетаданных = ЭлементДанных.Метаданные();
	
	Если АвтоРегистрацияРазрешена(ОбъектМетаданных, ИмяПланаОбмена) Тогда
		Возврат; // если установлен признак авторегистрации, то отсылаем объект "как есть"
	КонецЕсли;
	
	ИмяБазовогоТипа = ОбщегоНазначения.ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
	
	Если    ИмяБазовогоТипа = ОбщегоНазначения.ИмяТипаСправочники()
		ИЛИ ИмяБазовогоТипа = ОбщегоНазначения.ИмяТипаДокументы()
		ИЛИ ИмяБазовогоТипа = ОбщегоНазначения.ИмяТипаПланыВидовХарактеристик()
		ИЛИ ИмяБазовогоТипа = ОбщегоНазначения.ИмяТипаПланыСчетов()
		ИЛИ ИмяБазовогоТипа = ОбщегоНазначения.ИмяТипаПланыВидовРасчета()
		ИЛИ ИмяБазовогоТипа = ОбщегоНазначения.ИмяТипаБизнесПроцессы()
		ИЛИ ИмяБазовогоТипа = ОбщегоНазначения.ИмяТипаЗадачи() Тогда
		
		// определяем массив узлов для регистрации объекта
		МассивУзловДляРегистрацииОбъекта = ОпределитьПолучателейПриВыгрузкеДанных(ЭлементДанных, ОбъектМетаданных, ИмяПланаОбмена);
		
		НомерВМассиве = МассивУзловДляРегистрацииОбъекта.Найти(УзелИнформационнойБазы);
		
		// если в массиве нет текущего узла, то посылаем удаление объекта
		Если НомерВМассиве = Неопределено Тогда
			
			// передаем информацию об удалении
			ОтправкаЭлемента = ОтправкаЭлементаДанных.Удалить;
			
		КонецЕсли;
		
	ИначеЕсли   ИмяБазовогоТипа = ОбщегоНазначения.ИмяТипаРегистрыСведений()
			ИЛИ ИмяБазовогоТипа = ОбщегоНазначения.ИмяТипаРегистрыНакопления()
			ИЛИ ИмяБазовогоТипа = ОбщегоНазначения.ИмяТипаРегистрыБухгалтерии()
			ИЛИ ИмяБазовогоТипа = ОбщегоНазначения.ИмяТипаРегистрыРасчета() Тогда
		
		ОбратныйИндекс = ЭлементДанных.Количество() - 1;
		
		Пока ОбратныйИндекс >= 0 Цикл
			
			СтрокаНабора = ЭлементДанных[ОбратныйИндекс];
			
			// определяем массив узлов для регистрации объекта
			МассивУзловДляРегистрацииОбъекта = ОпределитьПолучателейПриВыгрузкеСтрокиНабораЗаписей(ЭлементДанных, СтрокаНабора, ОбъектМетаданных, ИмяПланаОбмена);
			
			НомерВМассиве = МассивУзловДляРегистрацииОбъекта.Найти(УзелИнформационнойБазы);
			
			// если в массиве нет текущего узла, то удаляем строку из набора
			Если НомерВМассиве = Неопределено Тогда
				
				ЭлементДанных.Удалить(ОбратныйИндекс);
				
			КонецЕсли;
			
			ОбратныйИндекс = ОбратныйИндекс - 1;
			
		КонецЦикла;
			
	КонецЕсли;
	
КонецПроцедуры

//

// Процедура-обработчик события "ПередЗаписью" документов для механизма регистрации объектов на узлах
//
// Параметры:
//  Источник - ДокументОбъект - источник события
//  Отказ    - Булево - флаг отказа от выполнения обработчика
// 
Процедура МеханизмРегистрацииОбъектовПередЗаписьюДокумента(Источник, Отказ, РежимЗаписи, РежимПроведения) Экспорт
	
	МеханизмРегистрацииОбъектов(Источник, Отказ, РежимЗаписи);
	
КонецПроцедуры

// Процедура-обработчик события "ПередЗаписью" ссылочных типов данных (кроме документов) для механизма регистрации объектов на узлах
//
// Параметры:
//  Источник - источник события, кроме типа ДокументОбъект
//  Отказ    - Булево - флаг отказа от выполнения обработчика
// 
Процедура МеханизмРегистрацииОбъектовПередЗаписью(Источник, Отказ) Экспорт
	
	МеханизмРегистрацииОбъектов(Источник, Отказ);
	
КонецПроцедуры

// Процедура-обработчик события "ПередЗаписью" регистров для механизма регистрации объектов на узлах
//
// Параметры:
//  Источник  - НаборЗаписейРегистра - источник события
//  Отказ     - Булево - флаг отказа от выполнения обработчика
//  Замещение - Булево - признак замещения существующего набора записей
// 
Процедура МеханизмРегистрацииОбъектовПередЗаписьюРегистра(Источник, Отказ, Замещение) Экспорт
	
	МеханизмРегистрацииОбъектов(Источник, Отказ,, Замещение, Истина);
	
КонецПроцедуры

// Процедура-обработчик события "ПередУдалением" ссылочных типов данных для механизма регистрации объектов на узлах
//
// Параметры:
//  Источник - источник события
//  Отказ    - Булево - флаг отказа от выполнения обработчика
// 
Процедура МеханизмРегистрацииОбъектовПередУдалением(Источник, Отказ) Экспорт
	
	МеханизмРегистрацииОбъектов(Источник, Отказ,,,, Истина);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ЭКСПОРТНЫЕ ВНУТРЕННИЕ ПРОЦЕДУРЫ-ОБРАБОТЧИКИ СОБЫТИЙ ПОДПИСОК

// Процедура-обработчик события "ПередЗаписью" для узла любого плана обмена
//
// Параметры:
//  Источник - ПланОбменаОбъект - узел плана обмена, источник события
//  Отказ    - Булево - флаг отказа от выполнения обработчика
// 
Процедура ОбменДаннымиПередЗаписьюУзлаПланаОбменаПередЗаписью(Источник, Отказ) Экспорт
	
	Если Источник.ЭтоНовый() Тогда
		
		// если добавили новый узел, то:
		// - обновить список используемых ПО (если узел первый)
		// - обновить кешируемые ссылки всех узлов ПО
		// кеш открытых сеансов для МРО стал неактуальным
		ОбменДаннымиСервер.УстановитьДатуОбновленияПовторноИспользуемыхЗначенийМРО();
		
	КонецЕсли;
	
КонецПроцедуры

// Процедура-обработчик события "ПередУдалением" для узла любого плана обмена
//
// Параметры:
//  Источник - ПланОбменаОбъект - узел плана обмена, источник события
//  Отказ    - Булево - флаг отказа от выполнения обработчика
// 
Процедура ОбменДаннымиПередУдалениемУзлаПланаОбменаПередУдалением(Источник, Отказ) Экспорт
	
	// если удалили узел, то необходимо обновить кешируемые ссылки всех узлов ПО
	// кеш открытых сеансов для МРО стал неактуальным
	ОбменДаннымиСервер.УстановитьДатуОбновленияПовторноИспользуемыхЗначенийМРО();
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА РЕГИСТРАЦИИ ОБЪЕКТОВ

// Процедура механизма регистрации объектов. Предназначена для определения списка узлов получателей планов обмена
// на которых необходимо выполнить регистрацию объекта для последующей его выгрузки
// Включает в себя два последовательно работающие механизма - ВРО и ПРО.
// ВРО - механизм выборочной регистрации объектов;
// ПРО - механизм регистрации объектов по правилам регистрации;
// Вначале отрабатывает механизм ВРО, далее включается механизм ПРО.
// ВРО определяет на каких планах обмена должен быть зарегистрирован объект к выгрузке;
// ПРО определяет на каких узлах каждого плана обмена должен быть зарегистрирован объект.
//
// Параметры:
//  Источник - СправочникОбъект или ДокументОбъект - источник для получения значений реквизитов и др. свойств
//  Отказ - Булево - флаг отказа. Если флаг отказа взведен, то процедура не выполняется
// 
Процедура МеханизмРегистрацииОбъектов(Источник,
										Отказ,
										РежимЗаписи = Неопределено,
										Замещение = Ложь,
										ЭтоРегистр = Ложь,
										ЭтоУдалениеОбъекта = Ложь)
	//
	УстановитьПривилегированныйРежим(Истина);
	
	ОтключитьМеханизмРегистрацииОбъектов = Ложь;
	Если  Источник.ДополнительныеСвойства.Свойство("ОтключитьМеханизмРегистрацииОбъектов", ОтключитьМеханизмРегистрацииОбъектов)
		И ОтключитьМеханизмРегистрацииОбъектов = Истина Тогда
		
		Возврат; // отказались от выполнения МРО; выходим
	КонецЕсли;
	
	// проверяем актуальность кеша сеанса для МРО
	ОбновитьПовторноИспользуемыеЗначенияМРОПриНеобходимости();
	
	Если НЕ ПараметрыСеанса.ОбменДаннымиВключен Тогда
		Возврат;
	КонецЕсли;
	
	// определяем необходимость регистрации объекта на узле отправителе
	РегистрироватьОбъектНаУзлеОтправителе = Ложь;
	Если  Источник.ДополнительныеСвойства.Свойство("РегистрироватьОбъектНаУзлеОтправителе", РегистрироватьОбъектНаУзлеОтправителе)
		И РегистрироватьОбъектНаУзлеОтправителе Тогда
		
		// обнуляем ссылку на узел отправитель
		Источник.ОбменДанными.Отправитель = Неопределено;
		
	КонецЕсли;
	
	ОбъектМетаданных = Источник.Метаданные();
	
	// при физическом удалении объекта ВРО не выполняем
	ЗарегистрироватьОбъектКВыгрузке = ЭтоРегистр ИЛИ ЭтоУдалениеОбъекта;
	
	// получаем массив планов обмена для которых надо выполнять ПРО
	ПланыОбменаДляРегистрации = ОпределитьМассивПлановОбменаДляОбъекта(Источник, ОбъектМетаданных, РежимЗаписи, ЗарегистрироватьОбъектКВыгрузке);
	
	Если ПланыОбменаДляРегистрации.Количество() = 0 Тогда
		
		Возврат // для объекта нет потребности выполнять ПРО; выходим
	КонецЕсли;
	
	Если ЭтоРегистр Тогда
		
		// определяем узлы для регистрации набора записей регистра
		ОпределитьМассивУзловДляНабораЗаписей(Источник, ОбъектМетаданных, ПланыОбменаДляРегистрации, Замещение);
		
	Иначе
		
		// определяем узлы для регистрации объекта
		ОпределитьМассивУзловДляОбъекта(Источник, ОбъектМетаданных, ПланыОбменаДляРегистрации, ЭтоУдалениеОбъекта);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбновитьПовторноИспользуемыеЗначенияМРОПриНеобходимости() Экспорт
	
	АктуальнаяДата = ПолучитьФункциональнуюОпцию("АктуальнаяДатаОбновленияПовторноИспользуемыхЗначенийМРО");
	
	Если ПараметрыСеанса.ДатаОбновленияПовторноИспользуемыхЗначенийМРО <> АктуальнаяДата Тогда
		
		ОбменДаннымиСервер.ОбновитьПовторноИспользуемыеЗначенияМРО();
		
		// рекурсивный вызов для проверки
		ОбновитьПовторноИспользуемыеЗначенияМРОПриНеобходимости();
		
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА ВЫБОРОЧНОЙ РЕГИСТРАЦИИ ОБЪЕКТОВ (ВРО)

// таблица выполняемых действий функции в зависимости от значения флагов
//-------------------------------------------------------
//РегистрироватьОбъект | АвтоРегистрацияОбъектаРазрешена
//-------------------------------------------------------
//                   0 | 0     | ничего не выполнять
//                   1 | 1     | ничего не выполнять
//                   1 | 0     | выполнить ПРО для текущего плана обмена
//                   0 | 1     | удалить узлы авторегистрации для текущего плана обмена
//
Функция ОпределитьМассивПлановОбменаДляОбъекта(Источник, ОбъектМетаданных, РежимЗаписи, ЗарегистрироватьОбъектКВыгрузке)
	
	// возвращаемое значение функции
	ПланыОбменаДляРегистрации = Новый Массив;
	
	Для Каждого ИмяПланаОбмена ИЗ ПараметрыСеанса.ИспользуемыеПланыОбмена Цикл
		
		// флаг необходимости регистрации объекта на узлах текущего ПО
		РегистрироватьОбъект = НадоЗарегистрироватьОбъектКВыгрузке(Источник, ОбъектМетаданных, ИмяПланаОбмена, РежимЗаписи, ЗарегистрироватьОбъектКВыгрузке);
		
		// флаг наличия авторегистрации объекта на узлах текущего ПО
		АвтоРегистрацияОбъектаРазрешена = АвтоРегистрацияРазрешена(ОбъектМетаданных, ИмяПланаОбмена);
		
		Если Не РегистрироватьОбъект И АвтоРегистрацияОбъектаРазрешена Тогда
			
			// если объект регистрировать не нужно и он регистрируется автоматически,
			// то удаляем все узлы по авторегистрации для текущего плана обмена
			УдалитьУзлыАвторегистрацииПоПлануОбмена(Источник, ИмяПланаОбмена);
			
		ИначеЕсли РегистрироватьОбъект И Не АвтоРегистрацияОбъектаРазрешена Тогда
			
			// если надо зарегистрировать объект и признака авторегистрации нет,
			// то заполняем массив планов обмена для выполнения ПРО
			ПланыОбменаДляРегистрации.Добавить(ИмяПланаОбмена);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ПланыОбменаДляРегистрации
	
КонецФункции

Функция НадоЗарегистрироватьОбъектКВыгрузке(Источник, ОбъектМетаданных, ИмяПланаОбмена, РежимЗаписи, ЗарегистрироватьОбъектКВыгрузке)
	
	Если    ЗарегистрироватьОбъектКВыгрузке
		ИЛИ Источник.ЭтоНовый()
		ИЛИ Источник.ОбменДанными.Загрузка Тогда
		
		// для наборов записей регистров,
		// при физическом удалении объектов,
		// для новых объектов,
		// для объектов записанных по обмену данными
		// регистрируем изменения всегда
		Возврат Истина;
		
	ИначеЕсли  РежимЗаписи <> Неопределено
		И ИзмененоПроведениеДокумента(Источник, РежимЗаписи) Тогда
		
		// если изменен признак документа "Проведен", то считаем документ измененным
		Возврат Истина;
	КонецЕсли;
	
	ИмяОбъекта = ОбъектМетаданных.ПолноеИмя();
	
	ТаблицаРеквизитовРегистрации = ОбменДаннымиПовтИсп.ПолучитьТаблицуРеквизитовРегистрации(ИмяОбъекта, ИмяПланаОбмена);
	
	Если ТаблицаРеквизитовРегистрации.Количество() = 0 Тогда
		
		// если правила ВРО не заданы, то считаем, что фильтра ВРО нет.
		// объект модифицирован всегда
		Возврат Истина;
		
	КонецЕсли;
	
	Для Каждого СтрокаТаблицыРеквизитовРегистрации ИЗ ТаблицаРеквизитовРегистрации Цикл
		
		ЕстьИзмененияВерсийОбъектов = ОпределитьИзмененияВерсийОбъекта(Источник, СтрокаТаблицыРеквизитовРегистрации);
		
		Если ЕстьИзмененияВерсийОбъектов Тогда
			
			Возврат Истина;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// если дошли до конца, то объект не изменился по реквизитам регистрации;
	// регистрация на узлах не нужна
	Возврат Ложь;
	
КонецФункции

Функция ОпределитьИзмененияВерсийОбъекта(Объект, СтрокаТаблицыРеквизитовРегистрации)
	
	Если ПустаяСтрока(СтрокаТаблицыРеквизитовРегистрации.ИмяТабличнойЧасти) Тогда // реквизиты Шапки объекта
		
		ТаблицаРеквизитовРегистрацииВерсияОбъектаДоИзменения = ПолучитьТаблицуРеквизитовРегистрацииШапкиДоИзменения(Объект, СтрокаТаблицыРеквизитовРегистрации);
		
		ТаблицаРеквизитовРегистрацииВерсияОбъектаПослеИзменения = ПолучитьТаблицуРеквизитовРегистрацииШапкиПослеИзменения(Объект, СтрокаТаблицыРеквизитовРегистрации);
		
	Иначе // реквизиты ТЧ объекта
		
		ТаблицаРеквизитовРегистрацииВерсияОбъектаДоИзменения = ПолучитьТаблицуРеквизитовРегистрацииТабличнойЧастиДоИзменения(Объект, СтрокаТаблицыРеквизитовРегистрации);
		
		ТаблицаРеквизитовРегистрацииВерсияОбъектаПослеИзменения = ПолучитьТаблицуРеквизитовРегистрацииТабличнойЧастиПослеИзменения(Объект, СтрокаТаблицыРеквизитовРегистрации);
		
	КонецЕсли;
	
	Возврат Не ТаблицыРеквизитовРегистрацииОдинаковые(ТаблицаРеквизитовРегистрацииВерсияОбъектаДоИзменения, ТаблицаРеквизитовРегистрацииВерсияОбъектаПослеИзменения, СтрокаТаблицыРеквизитовРегистрации);
	
КонецФункции

Функция ПолучитьТаблицуРеквизитовРегистрацииШапкиДоИзменения(Объект, СтрокаТаблицыРеквизитовРегистрации)
	
	ТекстЗапроса = "
	|ВЫБРАТЬ " + СтрокаТаблицыРеквизитовРегистрации.РеквизитыРегистрации 
	  + " ИЗ " + СтрокаТаблицыРеквизитовРегистрации.ИмяОбъекта + " КАК ТекущийОбъект
	|ГДЕ
	|   ТекущийОбъект.Ссылка = &Ссылка
	|";
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка);
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции

Функция ПолучитьТаблицуРеквизитовРегистрацииТабличнойЧастиДоИзменения(Объект, СтрокаТаблицыРеквизитовРегистрации)
	
	ТекстЗапроса = "
	|ВЫБРАТЬ "+ СтрокаТаблицыРеквизитовРегистрации.РеквизитыРегистрации
	+ " ИЗ " + СтрокаТаблицыРеквизитовРегистрации.ИмяОбъекта 
	+ "." + СтрокаТаблицыРеквизитовРегистрации.ИмяТабличнойЧасти + " КАК ТекущийОбъектИмяТабличнойЧасти
	|ГДЕ
	|   ТекущийОбъектИмяТабличнойЧасти.Ссылка = &Ссылка
	|";
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка);
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции

Функция ПолучитьТаблицуРеквизитовРегистрацииШапкиПослеИзменения(Объект, СтрокаТаблицыРеквизитовРегистрации)
	
	СтруктураРеквизитовРегистрации = СтрокаТаблицыРеквизитовРегистрации.СтруктураРеквизитовРегистрации;
	
	ТаблицаРеквизитовРегистрации = Новый ТаблицаЗначений;
	
	Для Каждого РеквизитРегистрации ИЗ СтруктураРеквизитовРегистрации Цикл
		
		ТаблицаРеквизитовРегистрации.Колонки.Добавить(РеквизитРегистрации.Ключ);
		
	КонецЦикла;
	
	СтрокаТаблицы = ТаблицаРеквизитовРегистрации.Добавить();
	
	Для Каждого РеквизитРегистрации ИЗ СтруктураРеквизитовРегистрации Цикл
		
		СтрокаТаблицы[РеквизитРегистрации.Ключ] = Объект[РеквизитРегистрации.Ключ];
		
	КонецЦикла;
	
	Возврат ТаблицаРеквизитовРегистрации;
КонецФункции

Функция ПолучитьТаблицуРеквизитовРегистрацииТабличнойЧастиПослеИзменения(Объект, СтрокаТаблицыРеквизитовРегистрации)
	
	ТаблицаРеквизитовРегистрации = Объект[СтрокаТаблицыРеквизитовРегистрации.ИмяТабличнойЧасти].Выгрузить(, СтрокаТаблицыРеквизитовРегистрации.РеквизитыРегистрации);
	
	Возврат ТаблицаРеквизитовРегистрации;
	
КонецФункции

Функция ТаблицыРеквизитовРегистрацииОдинаковые(Таблица1, Таблица2, СтрокаТаблицыРеквизитовРегистрации)
	
	ДобавитьИтераторТаблице(Таблица1, +1);
	ДобавитьИтераторТаблице(Таблица2, -1);
	
	ТаблицаРезультат = Таблица1.Скопировать();
	
	ОбщегоНазначенияКлиентСервер.ДополнитьТаблицу(Таблица2, ТаблицаРезультат);
	
	ТаблицаРезультат.Свернуть(СтрокаТаблицыРеквизитовРегистрации.РеквизитыРегистрации, "ИтераторТаблицыРеквизитовРегистрации");
	
	КоличествоОдинаковыхСтрок = ТаблицаРезультат.НайтиСтроки(Новый Структура ("ИтераторТаблицыРеквизитовРегистрации", 0)).Количество();
	
	КоличествоСтрокТаблицы = ТаблицаРезультат.Количество();
	
	Возврат КоличествоОдинаковыхСтрок = КоличествоСтрокТаблицы;
	
КонецФункции

Функция ИзмененоПроведениеДокумента(Источник, РежимЗаписи)
	
	Возврат (Источник.Проведен И РежимЗаписи = РежимЗаписиДокумента.ОтменаПроведения)
	 ИЛИ (НЕ Источник.Проведен И РежимЗаписи = РежимЗаписиДокумента.Проведение);
	
КонецФункции

Процедура ДобавитьИтераторТаблице(Таблица, ЗначениеИтератора)
	
	Таблица.Колонки.Добавить("ИтераторТаблицыРеквизитовРегистрации");
	
	Таблица.ЗаполнитьЗначения(ЗначениеИтератора, "ИтераторТаблицыРеквизитовРегистрации");
	
КонецПроцедуры

Процедура ДополнитьТаблицуУзлов(МассивУзлов, ИтоговаяТаблицаУзлов, Итератор)
	
	Для Каждого УзелИнформационнойБазы ИЗ МассивУзлов Цикл
		
		СтрокаТаблицы = ИтоговаяТаблицаУзлов.Добавить();
		СтрокаТаблицы.УзелИнформационнойБазы = УзелИнформационнойБазы;
		СтрокаТаблицы.Итератор               = Итератор;
		
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА РЕГИСТРАЦИИ ОБЪЕКТОВ (ПРО)

Процедура ОпределитьМассивУзловДляОбъекта(Источник, ОбъектМетаданных, ПланыОбменаДляРегистрации, ЭтоУдалениеОбъекта)
	
	ПроверятьСсылку = Не Источник.ЭтоНовый() И Не ЭтоУдалениеОбъекта;
	
	// получаем правило регистрации для объекта метаданных;
	// в зависимости о используемых планов обмена (см. ВРО)
	// правило каждый раз имеет разный состав параметров
	ОбщееПравилоРегистрацииОбъекта = ПолучитьОбщееПравилоРегистрацииОбъекта(ПланыОбменаДляРегистрации, ОбъектМетаданных, Источник, ПроверятьСсылку);
	
	Если ОбщееПравилоРегистрацииОбъекта = Неопределено Тогда
		
		// 1. динамически-созданное правило оказалось пустым
		// 2. объект не прошел фильтр ПРОБ
		Возврат;
		
	КонецЕсли;
	
	Если Не ПроверятьСсылку Тогда
		
		ЗначенияСвойствСсылки = Неопределено;
		
	Иначе
		
		// получаем структуру значений свойств для ссылки
		ЗначенияСвойствСсылки = ПолучитьЗначенияСвойствДляСсылки(Источник.Ссылка, ОбщееПравилоРегистрацииОбъекта, ОбъектМетаданных);
		
	КонецЕсли;
	
	// получаем структуру значений свойств для объекта
	ЗначенияСвойствОбъекта = ПолучитьЗначенияСвойствДляОбъекта(Источник, ОбщееПравилоРегистрацииОбъекта);
	
	// для новых объектов и для удаляемых физически объектов определяем узлы только по значениям свойств объекта;
	//
	// если ключевые реквизиты (элементы отбора) ссылки и объекта одинаковы,
	// то массив узлов определяем только по значениям реквизитов объекта,
	// т.к. они одинаковы для ссылки и для объекта.
	// (оптимизиция - не выполняем лишний запрос к ИБ для получения реквизитов ссылки)
	Если Не ПроверятьСсылку Тогда
		
		// определяем массив узлов для регистрации объекта
		МассивУзловДляРегистрации = ОпределитьМассивУзловПоЗначениямСвойств(ЗначенияСвойствОбъекта, ОбщееПравилоРегистрацииОбъекта, ОбъектМетаданных, ПланыОбменаДляРегистрации);
		
		// добавляем узлы для регистрации
		ДополнитьМассивПолучателейУзламиИзМассива(Источник, МассивУзловДляРегистрации);
		
	ИначеЕсли НЕ ЗначенияСвойствОбъектаИзменены(ЗначенияСвойствСсылки, ЗначенияСвойствОбъекта) Тогда
		
		// определяем массив узлов для регистрации объекта
		МассивУзловДляРегистрации = ОпределитьМассивУзловПоЗначениямСвойств(ЗначенияСвойствОбъекта, ОбщееПравилоРегистрацииОбъекта, ОбъектМетаданных, ПланыОбменаДляРегистрации);
		
		// добавляем узлы для регистрации
		ДополнитьМассивПолучателейУзламиИзМассива(Источник, МассивУзловДляРегистрации);
		
	Иначе // ключевые реквизиты фильтрации объекта по узлам изменены
		
		// определяем массив узлов для регистрации ссылки
		МассивУзловДляРегистрации = ОпределитьМассивУзловПоЗначениямСвойств(ЗначенияСвойствСсылки, ОбщееПравилоРегистрацииОбъекта, ОбъектМетаданных, ПланыОбменаДляРегистрации);
		
		// добавляем узлы для регистрации
		ДополнитьМассивПолучателейУзламиИзМассива(Источник, МассивУзловДляРегистрации);
		
		// определяем массив узлов для регистрации объекта
		МассивУзловДляРегистрации = ОпределитьМассивУзловПоЗначениямСвойств(ЗначенияСвойствОбъекта, ОбщееПравилоРегистрацииОбъекта, ОбъектМетаданных, ПланыОбменаДляРегистрации);
		
		// добавляем узлы для регистрации
		ДополнитьМассивПолучателейУзламиИзМассива(Источник, МассивУзловДляРегистрации);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ОпределитьМассивУзловДляНабораЗаписей(Источник, ОбъектМетаданных, ПланыОбменаДляРегистрации, Замещение)
	
	// получаем правило регистрации для объекта метаданных;
	// в зависимости о используемых планов обмена (см. ВРО)
	// правило каждый раз имеет разный состав параметров
	ОбщееПравилоРегистрацииОбъекта = ПолучитьОбщееПравилоРегистрацииОбъекта(ПланыОбменаДляРегистрации, ОбъектМетаданных, Источник, Ложь, Истина);
	
	Если ОбщееПравилоРегистрацииОбъекта = Неопределено Тогда
		
		// 1. динамически-созданное правило оказалось пустым
		// 2. объект не прошел фильтр ПРОБ
		Возврат;
		
	КонецЕсли;
	
	Если Замещение Тогда
		
		// определяем старый набор записей из глобального контекста
		ИмяБазовогоТипа = ОбщегоНазначения.ИмяБазовогоТипаПоОбъектуМетаданных(ОбъектМетаданных);
		
		Если ИмяБазовогоТипа = ОбщегоНазначения.ИмяТипаРегистрыСведений() Тогда
			
			СтарыйНаборЗаписей = РегистрыСведений[ОбъектМетаданных.Имя].СоздатьНаборЗаписей();
			
		ИначеЕсли ИмяБазовогоТипа = ОбщегоНазначения.ИмяТипаРегистрыНакопления() Тогда
			
			СтарыйНаборЗаписей = РегистрыНакопления[ОбъектМетаданных.Имя].СоздатьНаборЗаписей();
			
		ИначеЕсли ИмяБазовогоТипа = ОбщегоНазначения.ИмяТипаРегистрыБухгалтерии() Тогда
			
			СтарыйНаборЗаписей = РегистрыБухгалтерии[ОбъектМетаданных.Имя].СоздатьНаборЗаписей();
			
		ИначеЕсли ИмяБазовогоТипа = ОбщегоНазначения.ИмяТипаРегистрыРасчета() Тогда
			
			СтарыйНаборЗаписей = РегистрыРасчета[ОбъектМетаданных.Имя].СоздатьНаборЗаписей();
			
		Иначе
			
			Возврат; // внутренняя ошибка (ошибка встраивания библиотеки)
			
		КонецЕсли;
		
		Для Каждого ЗначениеОтбора Из Источник.Отбор Цикл
			
			Если ЗначениеОтбора.Использование = Ложь Тогда
				Продолжить;
			КонецЕсли;
			
			СтрокаОтбора = СтарыйНаборЗаписей.Отбор.Найти(ЗначениеОтбора.Имя);
			СтрокаОтбора.Значение = ЗначениеОтбора.Значение;
			СтрокаОтбора.Использование = Истина;
			
		КонецЦикла;
		
		СтарыйНаборЗаписей.Прочитать();
		
		// определяем массив узлов-получателей по старому набору записей
		ОпределитьМассивПолучателейПоНаборуЗаписей(Источник, СтарыйНаборЗаписей, ОбщееПравилоРегистрацииОбъекта, ОбъектМетаданных, ПланыОбменаДляРегистрации);
		
	КонецЕсли;
	
	// определяем массив узлов-получателей по текущему набору записей
	ОпределитьМассивПолучателейПоНаборуЗаписей(Источник, Источник, ОбщееПравилоРегистрацииОбъекта, ОбъектМетаданных, ПланыОбменаДляРегистрации);
	
КонецПроцедуры

Процедура ОпределитьМассивПолучателейПоНаборуЗаписей(Источник, НаборЗаписей, ОбщееПравилоРегистрацииОбъекта, ОбъектМетаданных, ПланыОбменаДляРегистрации)
	
	// получаем значение регистратора из отбора для набора записей
	Регистратор = Неопределено;
	
	ЭлементОтбора = НаборЗаписей.Отбор.Найти("Регистратор");
	
	ЕстьРегистратор = ЭлементОтбора <> Неопределено;
	
	Если ЕстьРегистратор Тогда
		
		Регистратор = ЭлементОтбора.Значение;
		
	КонецЕсли;
	
	Для Каждого СтрокаНабора ИЗ НаборЗаписей Цикл
		
		Если ЕстьРегистратор И СтрокаНабора["Регистратор"] = Неопределено Тогда
			
			Если Регистратор <> Неопределено Тогда
				
				СтрокаНабора["Регистратор"] = Регистратор;
				
			КонецЕсли;
			
		КонецЕсли;
		
		// получаем структуру значений свойств для объекта
		ЗначенияСвойствОбъекта = ПолучитьЗначенияСвойствДляОбъекта(СтрокаНабора, ОбщееПравилоРегистрацииОбъекта);
		
		// определяем массив узлов для регистрации объекта
		МассивУзловДляРегистрации = ОпределитьМассивУзловПоЗначениямСвойств(ЗначенияСвойствОбъекта, ОбщееПравилоРегистрацииОбъекта, ОбъектМетаданных, ПланыОбменаДляРегистрации);
		
		// добавляем узлы для регистрации
		ДополнитьМассивПолучателейУзламиИзМассива(Источник, МассивУзловДляРегистрации);
		
	КонецЦикла;
	
КонецПроцедуры

Функция ОпределитьМассивУзловПоЗначениямСвойств(ЗначенияСвойств, ПРО, ОбъектМетаданных, ПланыОбменаДляРегистрации)
	
	// возвращаемое значение функции
	МассивУзловРезультат = Новый Массив;
	
	// подготавливаем запрос для получения узлов планов обмена
	Запрос = Новый Запрос;
	
	// текст запроса
	Запрос.Текст = ПРО.ТекстЗапроса;
	
	// добавляем параметры, которые присутствуют всегда
	Для Каждого ИмяПланаОбмена ИЗ ПланыОбменаДляРегистрации Цикл
		
		Запрос.УстановитьПараметр(ИмяПланаОбмена + "ЭтотУзел", ОбменДаннымиПовтИсп.ПолучитьЭтотУзелПланаОбмена(ИмяПланаОбмена));
		
	КонецЦикла;
	
	// задаем значения параметров запроса из свойств объекта
	Для Каждого Элемент ИЗ ЗначенияСвойств Цикл
		
		Запрос.УстановитьПараметр("СвойствоОбъекта_" + Элемент.Ключ, Элемент.Значение);
		
	КонецЦикла;
	
	Попытка
		МассивУзловРезультат = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	Исключение
		
		// фиксируем ошибку в ЖР
		
		СтрокаСообщения = НСтр("ru = 'Ошибка при получении списка узлов получателей. Ошибка выполнения запроса: [ОписаниеОшибки]'");
		СтрокаСообщения = СтрЗаменить(СтрокаСообщения, "[ОписаниеОшибки]", ОписаниеОшибки());
		ЗаписьЖурналаРегистрацииПРО(СтрокаСообщения, ОбъектМетаданных);
		
		Возврат Новый Массив // возвращаем пустой массив
		
	КонецПопытки;
	
	// возвращаем результирующий массив узлов
	Возврат МассивУзловРезультат;
	
КонецФункции

Функция ПолучитьЗначенияСвойствДляОбъекта(Объект, ПРО)
	
	ЗначенияСвойств = Новый Структура;
	
	Для Каждого Элемент ИЗ ПРО.СвойстваОбъекта Цикл
		
		ЗначенияСвойств.Вставить(Элемент.Ключ, ПолучитьЗначениеСвойстваОбъекта(Объект, Элемент.Значение));
		
	КонецЦикла;
	
	Возврат ЗначенияСвойств;
	
КонецФункции

Функция ПолучитьЗначениеСвойстваОбъекта(Объект, СтрокаСвойствОбъекта)
	
	Значение = Объект;
	
	МассивПодстрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаСвойствОбъекта, ".");
	
	// значение получаем с учетом возможного разыменования свойства
	Для Каждого ИмяСвойства ИЗ МассивПодстрок Цикл
		
		Значение = Значение[ИмяСвойства];
		
	КонецЦикла;
	
	Возврат Значение;
	
КонецФункции

Функция ПолучитьЗначенияСвойствДляСсылки(Ссылка, ПРО, ОбъектМетаданных)
	
	ЗначенияСвойств = СкопироватьСтруктуру(ПРО.СвойстваОбъекта);
	
	Если ЗначенияСвойств.Количество() = 0 Тогда
		
		Возврат ЗначенияСвойств; // возвращаем пустую структуру
		
	КонецЕсли;
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	[СвойстваОбъектаСтрокой]
	|ИЗ
	|	[ОбъектМетаданныхИмя] КАК Таблица
	|ГДЕ
	|	Таблица.Ссылка = &Ссылка
	|";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[СвойстваОбъектаСтрокой]", ПРО.СвойстваОбъектаСтрокой);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ОбъектМетаданныхИмя]",    ПРО.ОбъектМетаданныхИмя);
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	
	Попытка
		Выборка = Запрос.Выполнить().Выбрать();
	Исключение
		
		// фиксируем ошибку в ЖР
		СтрокаСообщения = НСтр("ru = 'Ошибка при получении свойств ссылки. Ошибка выполнения запроса: [ОписаниеОшибки]'");
		СтрокаСообщения = СтрЗаменить(СтрокаСообщения, "[ОписаниеОшибки]", ОписаниеОшибки());
		ЗаписьЖурналаРегистрацииПРО(СтрокаСообщения, ОбъектМетаданных);
		
		// устанавливаем все свойства в значение "Неопределено"
		Для Каждого Элемент ИЗ ЗначенияСвойств Цикл
			
			ЗначенияСвойств[Элемент.Ключ] = Неопределено;
			
		КонецЦикла;
		
		Возврат ЗначенияСвойств;
	КонецПопытки;
	
	Если Выборка.Следующий() Тогда
		
		Для Каждого Элемент ИЗ ЗначенияСвойств Цикл
			
			ЗначенияСвойств[Элемент.Ключ] = Выборка[Элемент.Ключ];
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ЗначенияСвойств;
	
КонецФункции

Функция ЗначенияСвойствОбъектаИзменены(ЗначенияСвойств1, ЗначенияСвойств2)
	
	Для Каждого Элемент ИЗ ЗначенияСвойств1 Цикл
		
		Если ЗначенияСвойств1[Элемент.Ключ] <> ЗначенияСвойств2[Элемент.Ключ] Тогда
			
			Возврат Истина; // есть различия
			
		КонецЕсли;
		
	КонецЦикла;
	
	// если дошли до конца, то структуры имеют одинаковые значения свойств
	Возврат Ложь;
	
КонецФункции

Функция СкопироватьСтруктуру(СтруктураИсточник)
	
	СтруктураРезультат = Новый Структура;
	
	Для Каждого Элемент ИЗ СтруктураИсточник Цикл
		
		СтруктураРезультат.Вставить(Элемент.Ключ, Элемент.Значение);
		
	КонецЦикла;
	
	Возврат СтруктураРезультат;
	
КонецФункции

Процедура ДополнитьМассивПолучателейУзламиИзМассива(Источник, МассивУзлов)
	
	Для Каждого Элемент Из МассивУзлов Цикл
		
		Попытка
			
			Источник.ОбменДанными.Получатели.Добавить(Элемент);
			
		Исключение
			
			// фиксируем ошибку в ЖР
			ИмяПланаОбмена = Элемент.Метаданные().Имя;
			
			ОбъектМетаданных = Источник.Метаданные();
			
			СтрокаСообщения = НСтр("ru = 'Для состава плана обмена [ИмяПланаОбмена] не указана регистрация объекта [ПолноеИмя]'");
			СтрокаСообщения = СтрЗаменить(СтрокаСообщения, "[ИмяПланаОбмена]", ИмяПланаОбмена);
			СтрокаСообщения = СтрЗаменить(СтрокаСообщения, "[ПолноеИмя]",      ОбъектМетаданных.ПолноеИмя());
			
			ЗаписьЖурналаРегистрацииПРО(СтрокаСообщения, ОбъектМетаданных);
			
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура УдалитьУзлыАвторегистрацииПоПлануОбмена(Источник, ИмяПланаОбмена)
	
	// все узлы для текущего плана обмена
	МассивУзловПланаОбмена = ОбменДаннымиПовтИсп.ПолучитьМассивУзловПланаОбмена(ИмяПланаОбмена);
	
	ИтоговаяТаблицаУзлов = Новый ТаблицаЗначений;
	ИтоговаяТаблицаУзлов.Колонки.Добавить("УзелИнформационнойБазы");
	ИтоговаяТаблицаУзлов.Колонки.Добавить("Итератор");
	
	// заполняем ТЗ узлами авторегистрации для всех планов обмена
	ДополнитьТаблицуУзлов(Источник.ОбменДанными.Получатели, ИтоговаяТаблицаУзлов, +1);
	
	// заполняем ТЗ узлами авторегистрации для текущего плана обмена
	ДополнитьТаблицуУзлов(МассивУзловПланаОбмена,           ИтоговаяТаблицаУзлов, -1);
	
	ИтоговаяТаблицаУзлов.Свернуть("УзелИнформационнойБазы", "Итератор");
	
	// отбираем строки
	Отбор = Новый Структура("Итератор", 1);
	
	МассивУзловРезультат = ИтоговаяТаблицаУзлов.Скопировать(Отбор, "УзелИнформационнойБазы").ВыгрузитьКолонку("УзелИнформационнойБазы");
	
	// очищаем список получателей и заполняем его заново
	Источник.ОбменДанными.Получатели.Очистить();
	
	// добавляем узлы для регистрации объекта
	ДополнитьМассивПолучателейУзламиИзМассива(Источник, МассивУзловРезультат);
	
КонецПроцедуры

// ФУНКЦИИ ДИНАМИЧЕСКОГО СОЗДАНИЯ ОБЩЕГО ПРАВИЛА РЕГИСТАЦИИ ОБЪЕКТА

Функция ПолучитьОбщееПравилоРегистрацииОбъекта(ПланыОбменаДляРегистрации, ОбъектМетаданных, Источник, ПроверятьСсылку, ЭтоНаборЗаписейРегистра = Ложь)
	
	ОбъектМетаданныхПолноеИмя = ОбъектМетаданных.ПолноеИмя();
	
	// получаем массив всех ПРО для текущего объекта метаданных
	МассивПравилРегистрацииОбъекта = ПолучитьМассивПравилРегистрацииОбъекта(Источник, ПланыОбменаДляРегистрации, ОбъектМетаданных, ОбъектМетаданныхПолноеИмя);
	
	Если МассивПравилРегистрацииОбъекта.Количество() = 0 Тогда
		
		// фиксируем ошибку в журнале регистрации
		СтрокаСообщения = НСтр("ru = 'Для объекта [ОбъектМетаданныхПолноеИмя] не заданы правила регистрации.'");
		СтрокаСообщения = СтрЗаменить(СтрокаСообщения, "[ОбъектМетаданныхПолноеИмя]", ОбъектМетаданныхПолноеИмя);
		ЗаписьЖурналаРегистрацииПРО(СтрокаСообщения, ОбъектМетаданных);
		
		Возврат Неопределено // ПРО для объекта не заданы ни для одного плана обмена
	КонецЕсли;
	
	// выполняем правила регистрации по свойствам Объекта;
	// если на заданном Плане обмена регистрировать объект не нужно,
	// то удаляем это правило регистрации из массива правил МассивПравилРегистрацииОбъекта;
	// таким образом выключаем ПРО для соответствующего Плана обмена
	// ПРО = ПРОБ + ПРОП
	//
	// ПРОБ - Правила регистрации по свойствам Объекта
	// ПРОП - Правила регистрации по свойствам Плана обмена
	
	Если ЭтоНаборЗаписейРегистра Тогда
		
		Для Каждого СтрокаНабора ИЗ Источник Цикл
			
			ПравилаРегистрацииПоСвойствамОбъекта(МассивПравилРегистрацииОбъекта, СтрокаНабора, Ложь);
			
		КонецЦикла;
		
	Иначе
		
		ПравилаРегистрацииПоСвойствамОбъекта(МассивПравилРегистрацииОбъекта, Источник, ПроверятьСсылку);
		
	КонецЕсли;
	
	Если МассивПравилРегистрацииОбъекта.Количество() = 0 Тогда
		Возврат Неопределено; // по результату работы ПРОБ - объект регистрации не подлежит; выходим
	КонецЕсли;
	
	// получаем структуру свойств объекта для всех используемых планов обмена
	СвойстваОбъекта = ПолучитьСвойстваОбъектаПоПравиламРегистрацииОбъекта(МассивПравилРегистрацииОбъекта);
	
	// получаем свойства объекта в строковом представлении
	СвойстваОбъектаСтрокой = ПолучитьСвойстваОбъектаСтрокой(СвойстваОбъекта);
	
	// получаем текст запроса
	ТекстЗапроса = ПолучитьТекстЗапросаПоПравиламРегистрацииОбъекта(МассивПравилРегистрацииОбъекта);
	
	// создаем ПРО из полученных значений параметров
	ОбщееПравилоРегистрацииОбъекта = Новый Структура;
	
	ОбщееПравилоРегистрацииОбъекта.Вставить("ОбъектМетаданныхИмя",     ОбъектМетаданныхПолноеИмя);
	ОбщееПравилоРегистрацииОбъекта.Вставить("ТекстЗапроса",            ТекстЗапроса);
	ОбщееПравилоРегистрацииОбъекта.Вставить("СвойстваОбъекта",         СвойстваОбъекта);
	ОбщееПравилоРегистрацииОбъекта.Вставить("СвойстваОбъектаСтрокой",  СвойстваОбъектаСтрокой);
	
	Возврат ОбщееПравилоРегистрацииОбъекта
	
КонецФункции

Функция ПолучитьМассивПравилРегистрацииОбъекта(Объект, ПланыОбменаДляРегистрации, ОбъектМетаданных, ОбъектМетаданныхПолноеИмя)
	
	// возвращаемое значение функции
	Результат = Новый Массив;
	
	// получаем правила регистрации объектов
	ПравилаРегистрацииОбъектов = ПараметрыСеанса.ПравилаРегистрацииОбъектов.Получить();
	
	// устанавливаем отбор для поиска нужного ПРО
	Отбор = Новый Структура;
	Отбор.Вставить("ОбъектМетаданныхИмя", ОбъектМетаданныхПолноеИмя);
	
	Для Каждого ИмяПланаОбмена ИЗ ПланыОбменаДляРегистрации Цикл
		
		Отбор.Вставить("ИмяПланаОбмена", ИмяПланаОбмена);
		
		// получаем правило регистрации для объекта метаданных по текущему ПО
		ПравилоРегистрацииОбъекта = ПравилаРегистрацииОбъектов.НайтиСтроки(Отбор);
		
		Если ПравилоРегистрацииОбъекта.Количество() = 0 Тогда
			
			// фиксируем ошибку в журнале регистрации
			СтрокаСообщения = НСтр("ru = 'Для плана обмена [ИмяПланаОбмена] для объекта [ОбъектМетаданныхПолноеИмя] не задано правило регистрации'");
			СтрокаСообщения = СтрЗаменить(СтрокаСообщения, "[ИмяПланаОбмена]", ИмяПланаОбмена);
			СтрокаСообщения = СтрЗаменить(СтрокаСообщения, "[ОбъектМетаданныхПолноеИмя]", ОбъектМетаданныхПолноеИмя);
			ЗаписьЖурналаРегистрацииПРО(СтрокаСообщения, ОбъектМетаданных);
			
			Продолжить;
			
		КонецЕсли;
		
		// получаем все найденные ПРО для объекта метаданных
		Для Каждого ПРО ИЗ ПравилоРегистрацииОбъекта Цикл
			
			// {Обработчик: Перед обработкой} Начало
			Отказ = Ложь;
			
			ВыполнитьОбработчикПередОбработкойПРО(ПРО, Отказ, Объект, ОбъектМетаданных);
			
			Если Отказ Тогда
				Продолжить; // пропускаем правило
			КонецЕсли;
			// {Обработчик: Перед обработкой} Окончание
			
			// все отобранные ПРО для текущего объекта метаданнх будут выполнены по условию "ИЛИ"
			Результат.Добавить(ПРО);
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Результат
	
КонецФункции

Функция ПолучитьСвойстваОбъектаПоПравиламРегистрацииОбъекта(МассивПравилРегистрацииОбъекта)
	
	СвойстваОбъекта = Новый Структура;
	
	Для Каждого ПРО ИЗ МассивПравилРегистрацииОбъекта Цикл
		
		Для Каждого Элемент ИЗ ПРО.СвойстваОбъекта Цикл
			
			СвойстваОбъекта.Вставить(Элемент.Ключ, Элемент.Значение);
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат СвойстваОбъекта;
	
КонецФункции

// возвращает свойства объекта в строковом представлении
Функция ПолучитьСвойстваОбъектаСтрокой(СвойстваОбъекта)
	
	Результат = "";
	
	Для Каждого Элемент ИЗ СвойстваОбъекта Цикл
		
		Результат = Результат + Элемент.Значение + " КАК " + Элемент.Ключ + ", ";
		
	КонецЦикла;
	
	// удаляем последние два символа
	СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(Результат, 2);
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьТекстЗапросаПоПравиламРегистрацииОбъекта(МассивПравилРегистрацииОбъекта)
	
	ТекстЗапроса = "";
	
	Для Каждого ПРО ИЗ МассивПравилРегистрацииОбъекта Цикл
		
		СтрокаЛитерала = ?(ПустаяСтрока(ТекстЗапроса),"", Символы.ПС + "ОБЪЕДИНИТЬ ВСЕ" + Символы.ПС);
		
		ТекстЗапроса = ТекстЗапроса + СтрокаЛитерала + ПРО.ТекстЗапроса;
		
	КонецЦикла;
	
	Возврат ТекстЗапроса;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА РЕГИСТРАЦИИ ОБЪЕКТОВ ПРИ ВЫГРУЗКЕ ДАННЫХ (ПРО)

// Получает массив узлов-получателей для объекта при заданном плане обмена
//
// Параметры:
//  Источник       - СправочникОбъект или ДокументОбъект - источник для получения значений реквизитов и др. свойств
//  ИмяПланаОбмена - Строка - имя плана обмена как оно задано в конфигураторе
// 
// Возвращаемое значение:
//  МассивУзловРезультат - Массив - массив узлов-получателей для объекта
//
Функция ОпределитьПолучателейПриРегистрацииДанных(Источник, ОбъектМетаданных, Знач ИмяПланаОбмена) Экспорт
	
	// определяем массив узлов по правилам регистрации
	МассивУзловРезультат = ОпределитьМассивУзловДляОбъектаПоПлануОбмена(Источник, ОбъектМетаданных, ИмяПланаОбмена);
	
	Возврат МассивУзловРезультат;
	
КонецФункции

// Получает массив узлов-получателей для объекта при заданном плане обмена
//
// Параметры:
//  Источник       - СправочникОбъект или ДокументОбъект - источник для получения значений реквизитов и др. свойств
//  ИмяПланаОбмена - Строка - имя плана обмена как оно задано в конфигураторе
// 
// Возвращаемое значение:
//  МассивУзловРезультат - Массив - массив узлов-получателей для объекта
//
Функция ОпределитьПолучателейПриВыгрузкеДанных(Источник, ОбъектМетаданных, Знач ИмяПланаОбмена)
	
	Если АвтоРегистрацияРазрешена(ОбъектМетаданных, ИмяПланаОбмена) Тогда
		
		// определяем массив узлов по Авторегистрации
		МассивУзловРезультат = ОпределитьМассивУзловАвторегистрации(Источник);
		
	Иначе
		
		// определяем массив узлов по правилам регистрации
		МассивУзловРезультат = ОпределитьМассивУзловДляОбъектаПоПлануОбмена(Источник, ОбъектМетаданных, ИмяПланаОбмена);
		
	КонецЕсли;
	
	Возврат МассивУзловРезультат
	
КонецФункции

Функция ОпределитьПолучателейПриВыгрузкеСтрокиНабораЗаписей(Источник, СтрокаНабора, ОбъектМетаданных, Знач ИмяПланаОбмена)
	
	// возвращаемое значение функции
	МассивУзловДляРегистрации = Новый Массив;
	
	// массив с одним элементом
	ПланыОбменаДляРегистрации = Новый Массив;
	ПланыОбменаДляРегистрации.Добавить(ИмяПланаОбмена);
	
	// получаем правило регистрации для объекта метаданных;
	ОбщееПравилоРегистрацииОбъекта = ПолучитьОбщееПравилоРегистрацииОбъекта(ПланыОбменаДляРегистрации, ОбъектМетаданных, Источник, Ложь, Истина);
	
	Если ОбщееПравилоРегистрацииОбъекта = Неопределено Тогда
		
		// 1. динамически-созданное правило оказалось пустым
		// 2. объект не прошел фильтр ПРОБ
		// возвращаем пустой массив
		Возврат МассивУзловДляРегистрации;
	КонецЕсли;
	
	// получаем структуру значений свойств для объекта
	ЗначенияСвойствОбъекта = ПолучитьЗначенияСвойствДляОбъекта(СтрокаНабора, ОбщееПравилоРегистрацииОбъекта);
	
	// определяем массив узлов для регистрации объекта
	МассивУзловДляРегистрации = ОпределитьМассивУзловПоЗначениямСвойств(ЗначенияСвойствОбъекта, ОбщееПравилоРегистрацииОбъекта, ОбъектМетаданных, ПланыОбменаДляРегистрации);
	
	Возврат МассивУзловДляРегистрации;
	
КонецФункции

Функция ОпределитьМассивУзловДляОбъектаПоПлануОбмена(Источник, ОбъектМетаданных, ИмяПланаОбмена)
	
	// возвращаемое значение функции
	МассивУзловДляРегистрации = Новый Массив;
	
	// массив с одним элементом
	ПланыОбменаДляРегистрации = Новый Массив;
	ПланыОбменаДляРегистрации.Добавить(ИмяПланаОбмена);
	
	// получаем правило регистрации для объекта метаданных;
	ОбщееПравилоРегистрацииОбъекта = ПолучитьОбщееПравилоРегистрацииОбъекта(ПланыОбменаДляРегистрации, ОбъектМетаданных, Источник, Ложь);
	
	Если ОбщееПравилоРегистрацииОбъекта = Неопределено Тогда
		
		// 1. динамически-созданное правило оказалось пустым
		// 2. объект не прошел фильтр ПРОБ
		// возвращаем пустой массив
		Возврат МассивУзловДляРегистрации
	КонецЕсли;
	
	// получаем структуру значений свойств для объекта
	ЗначенияСвойствОбъекта = ПолучитьЗначенияСвойствДляОбъекта(Источник, ОбщееПравилоРегистрацииОбъекта);
	
	// определяем массив узлов для регистрации объекта
	МассивУзловДляРегистрации = ОпределитьМассивУзловПоЗначениямСвойств(ЗначенияСвойствОбъекта, ОбщееПравилоРегистрацииОбъекта, ОбъектМетаданных, ПланыОбменаДляРегистрации);
	
	Возврат МассивУзловДляРегистрации
	
КонецФункции

Функция ОпределитьМассивУзловАвторегистрации(Объект)
	
	МассивУзловАвторегистрации = Новый Массив;
	
	Объект.ОбменДанными.Получатели.Заполнить();
	
	Для Каждого Элемент Из Объект.ОбменДанными.Получатели Цикл
		
		МассивУзловАвторегистрации.Добавить(Элемент);
		
	КонецЦикла;
	
	Возврат МассивУзловАвторегистрации;
	
КонецФункции

Функция АвтоРегистрацияРазрешена(ОбъектМетаданных, ИмяПланаОбмена)
	
	// получаем коллекцию объектов метаданных, входящих в состав плана обмена
	СоставПланаОбмена = Метаданные.ПланыОбмена[ИмяПланаОбмена].Состав;
	
	ЭлементСоставаПланаОбмена = СоставПланаОбмена.Найти(ОбъектМетаданных);
	
	Если ЭлементСоставаПланаОбмена = Неопределено Тогда
		Возврат Истина; // объект метаданных не входит в состав плана обмена
	КонецЕсли;
	
	Возврат ЭлементСоставаПланаОбмена.АвтоРегистрация = АвтоРегистрацияИзменений.Разрешить;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРАВИЛ РЕГИСТРАЦИИ ПО СВОЙСТВАМ ОБЪЕКТА

Процедура ПравилаРегистрацииПоСвойствамОбъекта(МассивПравилРегистрацииОбъекта, Объект, ПроверятьСсылку)
	
	КолвоЭлементовКоллекции = МассивПравилРегистрацииОбъекта.Количество();
	
	Для ОбратныйИндекс = 1 По КолвоЭлементовКоллекции Цикл
		
		ТекущийИндекс = КолвоЭлементовКоллекции - ОбратныйИндекс;
		
		ПРО = МассивПравилРегистрацииОбъекта[ТекущийИндекс];
		
		Если Не ПРО.ПравилоПоСвойствамОбъектаПустое И Не ОбъектПрошелФильтрПравилРегистрацииПоСвойствам(ПРО, Объект, ПроверятьСсылку) Тогда
			
			МассивПравилРегистрацииОбъекта.Удалить(ТекущийИндекс);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьЗначенияСвойствИзОбъекта(ДеревоЗначений, Объект)
	
	Для Каждого СтрокаДерева ИЗ ДеревоЗначений.Строки Цикл
		
		Если СтрокаДерева.ЭтоГруппа Тогда
			
			ЗаполнитьЗначенияСвойствИзОбъекта(СтрокаДерева, Объект);
			
		Иначе
			
			СтрокаДерева.ЗначениеСвойства = ПолучитьЗначениеСвойстваОбъекта(Объект, СтрокаДерева.СвойствоОбъекта);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ПолучитьЗначенияАлгоритмовКонстант(ПРО, ДеревоЗначений)
	
	Для Каждого СтрокаДерева Из ДеревоЗначений.Строки Цикл
		
		Если СтрокаДерева.ЭтоГруппа Тогда
			
			ПолучитьЗначенияАлгоритмовКонстант(ПРО, СтрокаДерева);
			
		Иначе
			
			Если СтрокаДерева.ВидЭлементаОтбора = ОбменДаннымиСервер.ЭлементОтбораСвойствоАлгоритмЗначения() Тогда
				
				Значение = Неопределено;
				
				Попытка
					
					Выполнить(СтрокаДерева.ЗначениеКонстанты);
					
				Исключение
					
					// фиксируем ошибку в журнале регистрации
					СтрокаСообщения = НСтр("ru = 'Ошибка алгоритма вычисления значения константы:
												|План обмена: [ИмяПланаОбмена]
												|Объект метаданных: [ОбъектМетаданныхИмя]
												|Описание ошибки: [Описание]
												|Алгоритм:
												|// {Начало алгоритма}
												|[ЗначениеКонстанты]
												|// {Окончание алгоритма}
												|'");
					//
					СтрокаСообщения = СтрЗаменить(СтрокаСообщения, "[ИмяПланаОбмена]",      ПРО.ИмяПланаОбмена);
					СтрокаСообщения = СтрЗаменить(СтрокаСообщения, "[ОбъектМетаданныхИмя]", ПРО.ОбъектМетаданныхИмя);
					СтрокаСообщения = СтрЗаменить(СтрокаСообщения, "[Описание]",            ИнформацияОбОшибке().Описание);
					СтрокаСообщения = СтрЗаменить(СтрокаСообщения, "[ЗначениеКонстанты]",   Строка(СтрокаДерева.ЗначениеКонстанты));
					
					ЗаписьЖурналаРегистрацииПРО(СтрокаСообщения);
					
				КонецПопытки;
				
				СтрокаДерева.ЗначениеКонстанты = Значение;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура СоздатьДопустимыйОтборПоСвойствам(Объект, ДеревоЗначенийПриемник, ДеревоЗначенийИсточник)
	
	Для Каждого СтрокаДереваИсточника Из ДеревоЗначенийИсточник.Строки Цикл
		
		Если СтрокаДереваИсточника.ЭтоГруппа Тогда
			
			СтрокаДереваПриемника = ДеревоЗначенийПриемник.Строки.Добавить();
			
			ЗаполнитьЗначенияСвойств(СтрокаДереваПриемника, СтрокаДереваИсточника);
			
			СоздатьДопустимыйОтборПоСвойствам(Объект, СтрокаДереваПриемника, СтрокаДереваИсточника);
			
		Иначе
			
			Если ЦепочкаСвойствДействительна(Объект, СтрокаДереваИсточника.СвойствоОбъекта) Тогда
				
				СтрокаДереваПриемника = ДеревоЗначенийПриемник.Строки.Добавить();
				
				ЗаполнитьЗначенияСвойств(СтрокаДереваПриемника, СтрокаДереваИсточника);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ЦепочкаСвойствДействительна(Объект, Знач СтрокаСвойствОбъекта)
	
	Значение = Объект;
	
	МассивПодстрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаСвойствОбъекта, ".");
	
	// значение получаем с учетом возможного разыменования свойства
	Для Каждого ИмяСвойства ИЗ МассивПодстрок Цикл
		
		Попытка
			Значение = Значение[ИмяСвойства];
		Исключение
			Возврат Ложь;
		КонецПопытки;
		
	КонецЦикла;
	
	Возврат Истина;
КонецФункции

// Выполняем ПРОБ для ссылки и для объекта
// Результат учитываем по условию "ИЛИ"
// Если объект прошел фильтр ПРОБ по значения из ссылки,
// то ПРОБ для значений объекта уже не выполняем
//
Функция ОбъектПрошелФильтрПравилРегистрацииПоСвойствам(ПРО, Объект, ПроверятьСсылку)
	
	ПолучитьЗначенияАлгоритмовКонстант(ПРО, ПРО.ОтборПоСвойствамОбъекта);
	
	Если ПроверятьСсылку Тогда // проверка Ссылки; выполняем ПРОБ для ссылки
		
		ПРО.ОтборПоСвойствам = Обработки.ЗагрузкаПравилРегистрацииОбъектов.ИнициализацияТаблицыОтборПоСвойствамОбъекта();
		
		СоздатьДопустимыйОтборПоСвойствам(Объект.Ссылка, ПРО.ОтборПоСвойствам, ПРО.ОтборПоСвойствамОбъекта);
		
		ЗаполнитьЗначенияСвойствИзОбъекта(ПРО.ОтборПоСвойствам, Объект.Ссылка);
		
		Если УсловиеИстинноДляВеткиДереваЗначений(ПРО.ОтборПоСвойствам) Тогда
			
			Возврат Истина;
			
		КонецЕсли;
		
	КонецЕсли;
	
	ПРО.ОтборПоСвойствам = Обработки.ЗагрузкаПравилРегистрацииОбъектов.ИнициализацияТаблицыОтборПоСвойствамОбъекта();
	
	СоздатьДопустимыйОтборПоСвойствам(Объект, ПРО.ОтборПоСвойствам, ПРО.ОтборПоСвойствамОбъекта);
	
	ЗаполнитьЗначенияСвойствИзОбъекта(ПРО.ОтборПоСвойствам, Объект);
	
	Возврат УсловиеИстинноДляВеткиДереваЗначений(ПРО.ОтборПоСвойствам);
	
КонецФункции

// По умолчанию считаем, что элементы отбора корневой группы сравниваются по условию "И".
// Поэтому параметр ЭтоОператорИ по умолчанию принимает значение Истина
//
Функция УсловиеИстинноДляВеткиДереваЗначений(ДеревоЗначений, Знач ЭтоОператорИ = Истина)
	
	// инициализиция
	Если ЭтоОператорИ Тогда // И
		Результат = Истина;
	Иначе // ИЛИ
		Результат = Ложь;
	КонецЕсли;
	
	Для Каждого СтрокаДерева ИЗ ДеревоЗначений.Строки Цикл
		
		Если СтрокаДерева.ЭтоГруппа Тогда
			
			РезультатЭлемента = УсловиеИстинноДляВеткиДереваЗначений(СтрокаДерева, СтрокаДерева.ЭтоОператорИ);
		Иначе
			
			РезультатЭлемента = УсловиеИстинноДляЭлемента(СтрокаДерева, ЭтоОператорИ);
		КонецЕсли;
		
		Если ЭтоОператорИ Тогда // И
			
			Результат = Результат И РезультатЭлемента;
			
			Если Не Результат Тогда
				Возврат Ложь;
			КонецЕсли;
			
		Иначе // ИЛИ
			
			Результат = Результат ИЛИ РезультатЭлемента;
			
			Если Результат Тогда
				Возврат Истина;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

Функция УсловиеИстинноДляЭлемента(СтрокаДерева, ЭтоОператорИ)
	
	Перем ВидСравнения;
	
	ВидСравнения = СтрокаДерева.ВидСравнения;
	
	Попытка
		
		Если      ВидСравнения = "Равно"          Тогда Возврат СтрокаДерева.ЗначениеСвойства =  СтрокаДерева.ЗначениеКонстанты;
		ИначеЕсли ВидСравнения = "НеРавно"        Тогда Возврат СтрокаДерева.ЗначениеСвойства <> СтрокаДерева.ЗначениеКонстанты;
		ИначеЕсли ВидСравнения = "Больше"         Тогда Возврат СтрокаДерева.ЗначениеСвойства >  СтрокаДерева.ЗначениеКонстанты;
		ИначеЕсли ВидСравнения = "БольшеИлиРавно" Тогда Возврат СтрокаДерева.ЗначениеСвойства >= СтрокаДерева.ЗначениеКонстанты;
		ИначеЕсли ВидСравнения = "Меньше"         Тогда Возврат СтрокаДерева.ЗначениеСвойства <  СтрокаДерева.ЗначениеКонстанты;
		ИначеЕсли ВидСравнения = "МеньшеИлиРавно" Тогда Возврат СтрокаДерева.ЗначениеСвойства <= СтрокаДерева.ЗначениеКонстанты;
		КонецЕсли;
		
	Исключение
		
		Возврат Ложь;
		
	КонецПопытки;
	
	Возврат Ложь;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ РАБОТЫ С ЖУРНАЛОМ РЕГИСТРАЦИИ

Процедура ЗаписьЖурналаРегистрацииПРО(Комментарий, ОбъектМетаданных = Неопределено)
	
	ЗаписьЖурналаРегистрации("Обмен данными.Правила регистрации объектов", УровеньЖурналаРегистрации.Ошибка, ОбъектМетаданных, , Комментарий);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ-ОБРАБОТЧИКИ СОБЫТИЙ ПРО

Процедура ВыполнитьОбработчикПередОбработкойПРО(ПРО, Отказ, Объект, ОбъектМетаданных)
	
	Если ПРО.ЕстьОбработчикПередОбработкой Тогда
		
		Попытка
			
			Выполнить(ПРО.ПередОбработкой);
			
		Исключение
			
			// фиксируем ошибку в журнале регистрации
			СтрокаСообщения = НСтр("ru = 'Ошибка при выполнении обработчика: ""[ИмяОбработчика]""; План обмена: [ИмяПланаОбмена]; Объект метаданных: [ОбъектМетаданныхИмя]
				|Описание ошибки: [Описание]'");
			//
			СтрокаСообщения = СтрЗаменить(СтрокаСообщения, "[ИмяОбработчика]",     "Перед обработкой");
			СтрокаСообщения = СтрЗаменить(СтрокаСообщения, "[ИмяПланаОбмена]",      ПРО.ИмяПланаОбмена);
			СтрокаСообщения = СтрЗаменить(СтрокаСообщения, "[ОбъектМетаданныхИмя]", ПРО.ОбъектМетаданныхИмя);
			СтрокаСообщения = СтрЗаменить(СтрокаСообщения, "[Описание]",            ИнформацияОбОшибке().Описание);
			ЗаписьЖурналаРегистрацииПРО(СтрокаСообщения, ОбъектМетаданных);
			
			// флаг ошибки
			Отказ = Истина;
			
		КонецПопытки;
		
	КонецЕсли;
	
КонецПроцедуры
